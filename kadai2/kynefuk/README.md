# <課題 2> io.Reader と io.Writer

### io.Reader とは

一連のデータ(バイト列)の読み込み処理を抽象化したインターフェース。
読み込まれる対象データとしてバイト型の配列を受け取り、読み込んだバイト数とエラーを戻り値とする。

```
type Reader interface {
    Read(p []byte) (n int, err error)
}
```

### io.Writer とは

一連のデータ(バイト列)の書き込み処理を抽象化したインターフェース
書き込まれる対象データとしてバイト型の配列を受け取り、書き込んだバイト数とエラーを戻り値とする。

```
type Writer interface {
    Write(p []byte) (n int, err error)
}
```

## 標準パッケージでどのように使われているか

データの入出力を表現する様々なパッケージで io.Reader や io.Writer が実装している。
(標準入力を表す`os.Stdin`、標準出力を表す`os.Stdout`、ファイルの入出力を表現する`os.File`や、通信の入出力を表現する`net.Conn`など)

## io.Reader と io.Writer があることでどういう利点があるのか具体例を挙げて考えてみる

入力処理と出力処理の仕様をインターフェースとして定義しておくことで、様々な入出力処理を統一的に扱うことができ、プログラムの柔軟性が高くなる。
例えば、何らかの読み込み処理を行う関数の引数の型を`io.Reader`とすることで、`io.Reader`を実装している型であれば何でも受けることができる。
コマンドラインのの処理内容を出力する標準出力や、エラーを表示する標準エラー出力のフィールドの型として io.Writer を指定することで、テスト時に、`bytes.Buffer`などに切り替えることができ、テスト容易性を高めることができる。

```
type Command struct {
	OutStream, ErrStream io.Writer
}
```
